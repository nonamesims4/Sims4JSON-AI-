<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sims4JSONファイル専用AI依頼文付きリトライツール</title>
    <!-- Tailwind CSSをCDN経由で読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* スクロールバーのスタイルをカスタマイズ */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-thumb {
            background-color: #d1d5db;
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-track {
            background-color: #f9fafb;
        }
    </style>
</head>
<body class="p-4 sm:p-8 bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="max-w-4xl w-full bg-white rounded-2xl shadow-xl p-6 sm:p-10 border-4 border-purple-500">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center mb-6 text-purple-700 leading-tight">Sims4JSONファイル専用<br>AI依頼文付きリトライツール✨</h1>
        <p class="text-center text-gray-600 mb-4">Sims4Translatorにも対応しました！<br>辞書データを入力し、ファイルをアップロードして、翻訳されたテキストをプレビュー・ダウンロードしましょう！</p>
        
        <!-- コピペ用テキストエリアとボタンのコンテナ -->
        <div class="flex flex-col mb-6">
            <label for="exampleDictionary" class="block text-gray-700 font-bold mb-2">
                AIへの依頼文（コピー＆ペーストしてね！）<br>
                ★の部分を変更するとリライト文を変化させられます！
            </label>
            <p class="text-sm text-gray-600 mb-2">AIにJSONファイルを添付し、この依頼文を貼り付け送信（添付できない場合は依頼文後にJSONの内容を貼り付け）</p>
            <div class="flex items-center gap-2">
                <textarea
                    id="exampleDictionary"
                    rows="10"
                    class="w-full p-4 text-sm text-gray-800 bg-gray-50 border border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-purple-500 transition duration-300 resize-none"
                >シムズ4のゲームMOD用JSONの自然な日本語訳のためにPython用の置換辞書を作成してください。
Python辞書はJSON文字列化してください。
{0.SimFirstName}、{1.SimFirstName}、{M0.彼}、{F0.彼女} などのタグは「必ず形を変えず・翻訳せず」残してください。
もし小文字化や未翻訳、誤りがあれば必ず正しいタグ表記（大文字小文字含む）に直してください。
タグ部分以外は自然な日本語になるよう、特に接続詞や言い回しを直してください。
未翻訳の文章部分があれば日本語にしてください。文章のトーンは統一してください（★この後に追記するとリライト文が変化します★例；おねえ言葉にしてなど）
辞書は「置換前の文章（タグ抜き）」をキー、「自然で正しい日本語」をバリューとしたJSON形式でください。
例：「警察が{1.SimFirstName}を逮捕しに来ています。」 → 「警察が{1.SimFirstName}を逮捕に来ています。」「{M0.彼は}は」 → 「{M0.彼}は」
さらに、__PH_0__は{0.SimFirstName}に、__PH_1__は{1.SimFirstName}に置換してください。</textarea>
                <button
                    id="copyDictionaryButton"
                    class="px-4 py-2 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition duration-300 ease-in-out transform hover:scale-105 whitespace-nowrap"
                >
                    コピー
                </button>
            </div>
            <div id="copyStatusMessage" class="text-right text-sm text-green-600 font-medium mt-1 opacity-0 transition-opacity duration-300"></div>
        </div>
        
        <!-- 辞書データの入力エリア -->
        <div class="mb-6">
            <label for="dictionaryInput" class="block text-gray-700 font-bold mb-2">辞書データ (JSON形式)ここにAIからの文章を例文の用に貼り付けてね！</label>
            <textarea
                id="dictionaryInput"
                rows="5"
                placeholder="AIが生成した辞書データをJSON形式でここに貼り付けてください。例：{    &quot;置換前のテキスト1&quot;: &quot;置換後のテキスト1&quot;,    &quot;置換前のテキスト2&quot;: &quot;置換後のテキスト2&quot;}"
                class="w-full p-4 text-sm text-gray-800 bg-gray-50 border border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-purple-500 transition duration-300 resize-none"
            >{
"お腹が空いた。何か食べたい。": "あら、お腹がペコペコよ〜！なんか美味しいものちょうだい！",
"このパーティーは最高です！": "まぁ、このパーティーったら最高じゃない！アタシ、テンション上がっちゃうわ！",
"テレビを見たい。": "テレビでも見て、まったり過ごそうかしらね。",
"仕事に行きたくないな。": "もう！お仕事なんて行きたくないわぁ。",
"新しい服を買いに行こう。": "新しいお洋服、ゲットしにお買い物に行かなくっちゃ！",
"{F0.彼女}のライトビールは美味しい": "{F0.彼女}のライトビール、まじ美味しいわ！",
"{F0.彼女}と{M0.彼}の友達は実は付き合ってるって噂": "ねぇ聞いて！{F0.彼女}と{M0.彼}の友達、実は付き合ってるらしいのよ！"
}</textarea>
        </div>
        
        <!-- ファイル選択とボタンのコンテナ -->
        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
            <input
                type="file"
                id="fileInput"
                class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100 transition duration-300"
            >
            <button
                id="convertButton"
                class="w-full sm:w-auto px-6 py-3 bg-gray-400 text-white font-bold rounded-full shadow-lg cursor-not-allowed transition duration-300 ease-in-out transform hover:scale-105"
                disabled
            >
                変換する
            </button>
            <button
                id="downloadButton"
                class="w-full sm:w-auto px-6 py-3 bg-gray-400 text-white font-bold rounded-full shadow-lg cursor-not-allowed transition duration-300 ease-in-out transform hover:scale-105"
                disabled
            >
                ダウンロード
            </button>
        </div>

        <div id="statusMessage" class="text-center mb-6 font-medium hidden"></div>

        <!-- テキストエリアのグリッドレイアウト -->
        <div class="grid md:grid-cols-2 gap-6">
            <div class="flex flex-col">
                <label for="originalTextarea" class="block text-gray-700 font-bold mb-2">置換前（原文）</label>
                <textarea
                    id="originalTextarea"
                    rows="15"
                    class="w-full p-4 text-sm text-gray-800 bg-gray-50 border border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-purple-500 transition duration-300 resize-none"
                    readonly
                ></textarea>
            </div>
            <div class="flex flex-col">
                <label for="previewTextarea" class="block text-gray-700 font-bold mb-2">置換後（プレビュー）</label>
                <textarea
                    id="previewTextarea"
                    rows="15"
                    class="w-full p-4 text-sm text-gray-800 bg-gray-50 border border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-purple-500 transition duration-300 resize-none"
                    readonly
                ></textarea>
            </div>
        </div>
        
        <!-- GitHubリポジトリへのリンク -->
        <div class="text-center mt-8">
            <a href="https://github.com/nonamesims4/Sims4JSON-AI-" class="text-purple-600 hover:text-purple-800 font-semibold text-sm transition duration-300 underline">
                元のGitHubリポジトリはこちら✨
            </a>
        </div>
    </div>
    <script>
        // DOM要素の取得
        const fileInput = document.getElementById('fileInput');
        const dictionaryInput = document.getElementById('dictionaryInput');
        const originalTextarea = document.getElementById('originalTextarea');
        const previewTextarea = document.getElementById('previewTextarea');
        const convertButton = document.getElementById('convertButton');
        const downloadButton = document.getElementById('downloadButton');
        const statusMessage = document.getElementById('statusMessage');
        const exampleDictionary = document.getElementById('exampleDictionary');
        const copyDictionaryButton = document.getElementById('copyDictionaryButton');
        const copyStatusMessage = document.getElementById('copyStatusMessage');

        let convertedData = null; // 変換後のデータを保持する変数
        let originalFileName = ''; // 元のファイル名を保持

        // タグの代表表記を決めて正規化する関数
        // この関数に、AIの誤表記や表記ゆれパターンを随時追加してください。
        function normalizeTags(text) {
            if (typeof text !== 'string') return text;
            
            // 例: {M0.His}, {m0.his} -> {M0.彼}
            // 例: {F0.Her}, {f0.her} -> {F0.彼女}
            return text
                .replace(/\{[mM]0\.(his|His|HIM|he)\}/g, '{M0.彼}')
                .replace(/\{[fF]0\.(her|Her|SHE|she)\}/g, '{F0.彼女}');
        }

        // タグを抜いて比較用文字列として抽出する関数
        function extractReplaceTarget(text) {
            // まずタグを正規化し、その後タグ自体を削除してトリム
            return normalizeTags(text).replace(/\{[^\}]+\}/g, '').trim();
        }

        // PHタグをSimsのタグに置換する関数
        function replacePlaceholders(text) {
            return text.replace(/__PH_0__/g, '{0.SimFirstName}')
                        .replace(/__PH_1__/g, '{1.SimFirstName}');
        }

        // JSONオブジェクトを再帰的に走査して置換する関数
        function deepReplace(obj, replacementDict) {
            // ① Sims4公式 Locale/Entries 形式
            if (obj && typeof obj === 'object' && obj.Locale && Array.isArray(obj.Entries)) {
                const newEntries = obj.Entries.map(entry => {
                    if (entry && typeof entry.Value === 'string') {
                        const processedValue = replacePlaceholders(normalizeTags(entry.Value));
                        const cleanedValue = extractReplaceTarget(processedValue);
                        let replacedValue = processedValue;
                        for (const [dictKey, dictValue] of Object.entries(replacementDict)) {
                            if (cleanedValue === extractReplaceTarget(dictKey)) {
                                replacedValue = normalizeTags(dictValue);
                                break;
                            }
                        }
                        return { ...entry, Value: replacedValue };
                    }
                    return entry;
                });
                return { ...obj, Entries: newEntries };
            }

            // ② 通常の配列／オブジェクト
            if (Array.isArray(obj)) {
                return obj.map(item => deepReplace(item, replacementDict));
            }
            if (typeof obj === 'object' && obj !== null) {
                const newObj = {};
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        newObj[key] = deepReplace(obj[key], replacementDict);
                    }
                }
                return newObj;
            }

            // ③ 文字列置換
            if (typeof obj === 'string') {
                const processedValue = replacePlaceholders(normalizeTags(obj));
                const cleanedValue = extractReplaceTarget(processedValue);
                for (const [dictKey, dictValue] of Object.entries(replacementDict)) {
                    if (cleanedValue === extractReplaceTarget(dictKey)) {
                        return normalizeTags(dictValue);
                    }
                }
                return processedValue;
            }
            return obj;
        }

        // ファイルまたは辞書が変更されたときに変換ボタンの状態を更新する
        function updateButtonState() {
            const fileSelected = fileInput.files.length > 0;
            const dictionaryValid = isDictionaryValid();
            
            if (fileSelected && dictionaryValid) {
                convertButton.disabled = false;
                convertButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                convertButton.classList.add('bg-purple-600', 'hover:bg-purple-700');
            } else {
                convertButton.disabled = true;
                convertButton.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                convertButton.classList.add('bg-gray-400', 'cursor-not-allowed');
            }
        }

        // 辞書の内容が有効なJSONかチェックする関数
        function isDictionaryValid() {
            try {
                const dictText = dictionaryInput.value;
                if (!dictText.trim()) {
                    return false;
                }
                JSON.parse(dictText);
                statusMessage.classList.add('hidden');
                return true;
            } catch (e) {
                statusMessage.textContent = 'エラー: 辞書データは有効なJSON形式ではありません。';
                statusMessage.classList.remove('hidden');
                statusMessage.classList.remove('text-green-500');
                statusMessage.classList.add('text-red-500');
                return false;
            }
        }

        // イベントリスナー：ファイルが選択されたとき
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                originalTextarea.value = '';
                previewTextarea.value = '';
                return;
            }

            originalFileName = file.name;
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const text = e.target.result;
                originalTextarea.value = text;
                updateButtonState();
                
                // プレビューとダウンロードボタンを初期化
                previewTextarea.value = '';
                downloadButton.disabled = true;
                downloadButton.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                downloadButton.classList.add('bg-gray-400', 'cursor-not-allowed');
            };

            reader.readAsText(file);
        });

        // イベントリスナー：辞書入力エリアが変更されたとき
        dictionaryInput.addEventListener('input', updateButtonState);

        // イベントリスナー：変換ボタンがクリックされたとき
        convertButton.addEventListener('click', () => {
            try {
                // 辞書データをパース
                const replacementDict = JSON.parse(dictionaryInput.value);
                // JSON文字列をパース
                const originalData = JSON.parse(originalTextarea.value);
                
                // 変換ロジックの実行
                convertedData = deepReplace(originalData, replacementDict);

                // プレビューエリアに表示
                previewTextarea.value = JSON.stringify(convertedData, null, 2);
                
                // 成功メッセージ
                statusMessage.textContent = '変換が完了しました！プレビューを確認してダウンロードしてください。';
                statusMessage.classList.remove('hidden', 'text-red-500');
                statusMessage.classList.add('text-green-500');

                // ダウンロードボタンを有効化
                downloadButton.disabled = false;
                downloadButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                downloadButton.classList.add('bg-purple-600', 'hover:bg-purple-700');

            } catch (error) {
                // エラーメッセージ
                statusMessage.textContent = `エラーが発生しました: ${error.message}`;
                statusMessage.classList.remove('hidden', 'text-green-500');
                statusMessage.classList.add('text-red-500');
                console.error("変換エラー:", error);
            }
        });

        // イベントリスナー：ダウンロードボタンがクリックされたとき
        downloadButton.addEventListener('click', () => {
            if (!convertedData) {
                return;
            }
            
            // JSONデータをBlobに変換
            const jsonString = JSON.stringify(convertedData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            // ダウンロードリンクを作成
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // ダウンロードファイル名を設定（元のファイル名に "_mod" を追加）
            const parts = originalFileName.split('.');
            const newFileName = parts[0] + "_mod." + parts[1];
            a.download = newFileName;
            
            // 仮想的にリンクをクリック
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
        
        // コピーボタンのイベントリスナー
        copyDictionaryButton.addEventListener('click', () => {
            exampleDictionary.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    copyStatusMessage.textContent = 'コピーしました！';
                    copyStatusMessage.classList.remove('opacity-0');
                    setTimeout(() => {
                        copyStatusMessage.classList.add('opacity-0');
                    }, 2000); // 2秒後にメッセージを非表示にする
                } else {
                    copyStatusMessage.textContent = 'コピーに失敗しました。';
                    copyStatusMessage.classList.remove('opacity-0');
                    copyStatusMessage.classList.add('text-red-600');
                    setTimeout(() => {
                        copyStatusMessage.classList.add('opacity-0');
                        copyStatusMessage.classList.remove('text-red-600');
                    }, 2000);
                }
            } catch (err) {
                console.error('コピーエラー:', err);
            }
        });

        // 初期状態でボタンの状態を更新
        updateButtonState();
    </script>
</body>
</html>
